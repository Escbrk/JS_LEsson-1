//! Метод concat()
//! Функции
//! Псевдомассив arguments
//! Преобразование псевдомассива
//! Паттерн «Ранний возврат»
//! Функциональное выражение
//! Стек вызовов
//! Массивы
//! Передача по значению
//! Передача по ссылке
//! Найти самое маленькое число в массиве:
//! Найти самое большое число в массиве:
//! Метод join():
//! Метод concat() :
//! ФУНКЦИИ
//! ___________________________________________
//! Объекты
//! Свойства
document.querySelector(".js-magic__btn");
//! Короткая запись сво-тв:
//! Вычисляемые св-ва
//! Ссылочный тип {} === {}
//! Массивы и функции это объекты
//! Перебор через for...in и Object.keys | values | entries
//!________________________________________
//! Сшиваем несколько массивов в один через concat() и spread
//! Деструктуризация массивов
//! Операция rest (сбор)
//! EXAMPLE
//! CART_____________________
//! CART_____________________
//! CALLBACK
//! Функция doMath(a, b, callback)
//! Отложеный вызов: регистрация событий
//! Отложеный вызов: геолокация
//! Отложеный вызов: интервалы
//! Фильтр
//! ЗАМЫКАНИЕ
//! Поварёнок (пример)
//! Округлятор 🤷‍♂️
//! Приватные данные и функции - скрытие реализации, интерфейс
//! Явный и неявный возврат
//! Псевдомассив arguments
//!_____________
//!_______
//!_______
//!--------------------------------
//! Получаем массив имён всех игроков
//! Увеличиваем кол-во поинтов каждого игрока на 10%
//! Увеличиваем кол-во часов игрока по ID
//! Ищем игрока по ID
//! Ищем игрока по имени
//! Считаем общую зарплату
//! Считаем общее кол-во часов
//! Считаем общую сумму товаров корзины
//! Собираем все тего из твитов
//! Ведем статистику тегов
//! #1
//! #2
//! #3
//! Кастомная сортировка сложных типов
//! По игровому времени
//! Цепочка
//! 💩способ____________
//! Цепочка предыдущих трех
//! isEmpty()
//! Новый синтаксис
//! Счетчик
//!     1. Если функция вызывается через new, создаётся пустой объект
//!     2. Функция вызывается в контексте созданного объекта,
//!         то есть в this записывается ссылка на него
//!     3. В свойство this.__proto__ записывается ссылка на объект Car.prototype
//!         то есть Car.prototype это ПРОТОТИП будущего объекта (экземпляра)
//!     4. Ссылка на объект возвращается в место вызова new Car
//!     1. У каждого объекта есть свойство __proto__
//!     2. В этом свойстве лежит ссылка на его ПРОТОТИ, то есть другой объект
//!     3. При создании литерала объекта, в свойство __proto__ записывается ссылка на Функция.prototype
//!     4. Функция-конструктор это просто функция :)
//!     5. Всю магию делает оператор new
//!     6. Если функция вызывается через new, создаётся пустой объект
//!     7. Функция вызывается в контексте созданного объекта
//!     8. В свойство this.__proto__ записывается ссылка на объект Функция.prototype
//!     9. Ссылка на объект возвращается в место вызова new Функция()
const e={movieList:document.querySelector(".movie-list"),loadMore:document.querySelector(".js-load"),target:document.querySelector(".js-guard"),BASE_URL:"https://api.themoviedb.org/3/",ENDPOINT:"trending/movie/day",API_KEY:"d0f00e3970f1028763a1388502d0f412"};let t=1,r=new IntersectionObserver((function(r,s){r.forEach((r=>{r.isIntersecting&&(t+=1,n(t).then((t=>{e.movieList.insertAdjacentHTML("beforeend",o(t.results)),t.page===t.total_pages&&s.unobserve(e.target)})).catch((e=>console.error(e))))}))}),{root:null,rootMargin:"300px",threshold:1});function o(e){return e.map((({poster_path:e,title:t,overview:r})=>`<li style='list-style: none'>\n        <img src="https://image.tmdb.org/t/p/w500/${e}" alt="${t}" />\n        <h2>${t}</h2>\n        <p>${r}</p>\n      </li>`)).join(" ")}function n(t=1){return fetch(`${e.BASE_URL}${e.ENDPOINT}?api_key=${e.API_KEY}&page=${t}`).then((e=>{if(!e.ok)throw new Error(e.statusText);return e.json()}))}n().then((t=>{e.movieList.insertAdjacentHTML("beforeend",o(t.results)),r.observe(e.target)})).catch((e=>console.error(e)));
//# sourceMappingURL=index.4ae89cb9.js.map
